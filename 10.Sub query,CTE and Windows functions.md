# Subquery, CTE and Window Functions

SQL Server (SSMS)

---

# 1. Subquery

## What is a Subquery?

A **subquery** is a query written inside another SQL query.

* Inner query runs first
* Its result is used by outer query
* Also called **nested query**

---

## Why use Subquery?

Use subquery when:

* Condition depends on another query result
* Need comparison with aggregated values
* Need filtering based on another table

---

## Basic Syntax

```sql
SELECT columns
FROM table
WHERE column operator (
    SELECT column
    FROM table
);
```

---

## Practical Examples

### Example 1: Employees earning more than average salary

```sql
SELECT name, salary
FROM tbl_emp
WHERE salary > (
    SELECT AVG(salary)
    FROM tbl_emp
);
```

Explanation

* Inner query finds average salary
* Outer query returns employees earning more than average

---

### Example 2: Employees working in Hyderabad departments

```sql
SELECT name
FROM tbl_emp
WHERE dept_id IN (
    SELECT dept_id
    FROM tbl_dept
    WHERE location = 'Hyderabad'
);
```

---

### Example 3: Correlated Subquery – salary greater than department average

```sql
SELECT e.name, e.salary, e.dept_id
FROM tbl_emp e
WHERE salary > (
    SELECT AVG(salary)
    FROM tbl_emp
    WHERE dept_id = e.dept_id
);
```

Explanation
Inner query runs for each department.

---

### Example 4: Subquery in FROM (Derived table)

```sql
SELECT dept_id, AvgSalary
FROM (
    SELECT dept_id, AVG(salary) AS AvgSalary
    FROM tbl_emp
    GROUP BY dept_id
) t;
```

---

# 2. CTE (Common Table Expression)

---

## What is a CTE?

A **CTE** is a temporary named result set defined using **WITH** clause.

* Exists only for one query
* Improves readability
* Useful for complex queries

---

## Syntax

```sql
WITH cte_name AS (
    SELECT ...
)
SELECT *
FROM cte_name;
```

---

## Practical Examples

### Example 1: Department average salary using CTE

```sql
WITH DeptAvg AS (
    SELECT dept_id, AVG(salary) AS AvgSalary
    FROM tbl_emp
    GROUP BY dept_id
)
SELECT *
FROM DeptAvg;
```

---

### Example 2: Employees earning above department average

```sql
WITH DeptAvg AS (
    SELECT dept_id, AVG(salary) AS AvgSalary
    FROM tbl_emp
    GROUP BY dept_id
)
SELECT e.name, e.salary, e.dept_id
FROM tbl_emp e
JOIN DeptAvg d
ON e.dept_id = d.dept_id
WHERE e.salary > d.AvgSalary;
```

---

### Example 3: Multiple CTEs

```sql
WITH EmpCTE AS (
    SELECT * FROM tbl_emp
),
DeptCTE AS (
    SELECT * FROM tbl_dept
)
SELECT e.name, d.dept_name
FROM EmpCTE e
JOIN DeptCTE d
ON e.dept_id = d.dept_id;
```

---

### Example 4: Recursive CTE (Hierarchy)

```sql
WITH EmpHierarchy AS (
    SELECT eid, name, manager_id
    FROM tbl_emp
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.eid, e.name, e.manager_id
    FROM tbl_emp e
    JOIN EmpHierarchy h
    ON e.manager_id = h.eid
)

SELECT *
FROM EmpHierarchy;
```

Used for:

* Employee hierarchy
* Parent-child data

### Example 5:
```sql
WITH DeptStats AS (
    SELECT 
        deptno,
        SUM(sal) AS dept_total_salary,
        AVG(sal) AS dept_avg_salary
    FROM emp
    GROUP BY deptno
),
EmpRanked AS (
    SELECT 
        e.empno,
        e.ename,
        e.sal,
        e.deptno,
        d.dname,
        RANK() OVER (PARTITION BY e.deptno ORDER BY e.sal DESC) AS salary_rank
    FROM emp e
    JOIN dept d ON e.deptno = d.deptno
)
SELECT 
    er.empno,
    er.ename,
    er.sal,
    er.dname,
    er.salary_rank,
    ds.dept_total_salary,
    ds.dept_avg_salary,
    ROUND(er.sal - ds.dept_avg_salary, 2) AS diff_from_avg,
    CASE
        WHEN er.sal > ds.dept_avg_salary THEN 'Above Avg'
        WHEN er.sal < ds.dept_avg_salary THEN 'Below Avg'
        ELSE 'At Avg'
    END AS salary_position
FROM EmpRanked er
JOIN DeptStats ds ON er.deptno = ds.deptno
ORDER BY er.dname, er.salary_rank;
```
# 3. Window Functions

---

## What are Window Functions?

Window functions perform calculations across a set of rows **without grouping the result**.

Difference from GROUP BY:

* GROUP BY → reduces rows
* Window → keeps rows

---

## Syntax

```sql
function() OVER (
    PARTITION BY column
    ORDER BY column
)
```

---

## Practical Examples

### Example 1: Row number for employees

```sql
SELECT name, salary,
       ROW_NUMBER() OVER (ORDER BY salary DESC) AS RowNum
FROM tbl_emp;
```

---

### Example 2: Rank employees by salary

```sql
SELECT name, salary,
       RANK() OVER (ORDER BY salary DESC) AS RankValue
FROM tbl_emp;
```

---

### Example 3: Dense Rank

```sql
SELECT name, salary,
       DENSE_RANK() OVER (ORDER BY salary DESC) AS DenseRankValue
FROM tbl_emp;
```

---

### Example 4: Department-wise ranking

```sql
SELECT name, dept_id, salary,
       ROW_NUMBER() OVER (
           PARTITION BY dept_id
           ORDER BY salary DESC
       ) AS DeptRank
FROM tbl_emp;
```

---

### Example 5: Running total

```sql
SELECT eid, salary,
       SUM(salary) OVER (ORDER BY eid) AS RunningTotal
FROM tbl_emp;
```

---

### Example 6: Department total without GROUP BY

```sql
SELECT name, dept_id, salary,
       SUM(salary) OVER (PARTITION BY dept_id) AS DeptTotal
FROM tbl_emp;
```

---

### Example 7: Top 3 employees per department

```sql
SELECT *
FROM (
    SELECT name, dept_id, salary,
           ROW_NUMBER() OVER (
               PARTITION BY dept_id
               ORDER BY salary DESC
           ) AS rn
    FROM tbl_emp
) t
WHERE rn <= 3;
```


### Example 8:
```sql
SELECT 
    e.empno,
    e.ename,
    --e.job,
    --e.mgr,
    --e.hiredate,   
    --e.comm,
    e.deptno,
    d.dname,
     e.sal,

    -- -- RANKING FUNCTIONS
    RANK() OVER (ORDER BY e.sal DESC) AS salary_rank
    -- DENSE_RANK() OVER (ORDER BY e.sal DESC) AS salary_dense_rank,
    -- ROW_NUMBER() OVER (ORDER BY e.sal DESC) AS salary_row_number,
    -- NTILE(4) OVER (ORDER BY e.sal DESC) AS salary_quartile,

    -- -- AGGREGATE WINDOW FUNCTIONS
    -- SUM(e.sal) OVER (PARTITION BY e.deptno) AS dept_total_salary,
    -- AVG(e.sal) OVER (PARTITION BY e.deptno) AS dept_avg_salary,
    -- MIN(e.sal) OVER (PARTITION BY e.deptno) AS dept_min_salary,
    -- MAX(e.sal) OVER (PARTITION BY e.deptno) AS dept_max_salary,
    -- COUNT(*) OVER (PARTITION BY e.deptno) AS dept_emp_count,

    -- -- RUNNING TOTALS
    -- SUM(e.sal) OVER (ORDER BY e.sal ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total_salary,
    -- AVG(e.sal) OVER (ORDER BY e.sal ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_avg_salary,

    -- -- LAG/LEAD
    -- LAG(e.sal, 1) OVER (ORDER BY e.sal DESC) AS prev_salary,
    -- LEAD(e.sal, 1) OVER (ORDER BY e.sal DESC) AS next_salary,

    -- -- FIRST_VALUE, LAST_VALUE
    -- FIRST_VALUE(e.sal) OVER (PARTITION BY e.deptno ORDER BY e.sal DESC) AS dept_highest_salary,
    -- LAST_VALUE(e.sal) OVER (PARTITION BY e.deptno ORDER BY e.sal DESC 
    --     ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS dept_lowest_salary



FROM emp e
JOIN dept d ON e.deptno = d.deptno
order by sal desc;
```
---

# Execution Order (Important)

Logical order:

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. Window Functions
6. SELECT
7. ORDER BY

Window functions cannot be used in WHERE directly.

---

# When to Use What?

| Requirement                       | Use             |
| --------------------------------- | --------------- |
| Compare with aggregated value     | Subquery        |
| Improve readability / reuse logic | CTE             |
| Ranking, running total, analytics | Window Function |

---

# One-line Memory

Subquery filters data, CTE organizes complex logic, and Window Functions perform analytics without reducing rows.
