# 1. VIEW 

## What is a View?

A **View** is a virtual table created from a SELECT query.

* It **does not store data**
* It only stores the **query**
* When you select from a view, SQL Server fetches data from the original table

Think of it like:

> A saved SELECT query.

---

## Why use Views?

Use views when:

* Query is complex (joins, filters)
* Same query is used again and again
* You want to hide some columns (security)
* Used in reporting

---

## How View Works (Flow)

```
User → View → Actual Table
```

The view fetches data from the base table.

---

## Syntax

```sql
CREATE VIEW view_name
AS
SELECT column_list
FROM table_name
WHERE condition;
```

---

## Example

```sql
-- Create a view to show only required columns
CREATE VIEW vw_Employee
AS
SELECT 
    eid,        -- Employee ID
    name,       -- Employee Name
    salary      -- Salary
FROM tbl_emp;
```

Use the view:

```sql
-- Fetch data from view
SELECT * 
FROM vw_Employee;
```

What happens:

* SQL Server runs the stored SELECT query
* Data comes from `tbl_emp`

---

## View with Join (Real-time use)

```sql
CREATE VIEW vw_EmpDept
AS
SELECT 
    e.eid,
    e.name,
    d.dept_name
FROM tbl_emp e
JOIN tbl_dept d
ON e.dept_id = d.dept_id;
```

Used for:

* Reports
* Power BI
* Applications

---

## When NOT to use View

* When performance is critical (complex views)
* When data changes frequently and logic is heavy

---

# 2. INDEX
## What is an Index?

An **Index** is a structure that helps SQL Server **find data faster**.

Without index:

* SQL scans entire table (Full Table Scan)

With index:

* SQL directly finds the row (Index Seek)

Think of it like:

> Book index to find a page quickly.

---

## Why Index is needed?

Use index when:

* Column used in WHERE
* Column used in JOIN
* Column used in ORDER BY
* Column used in GROUP BY

---

## Types of Index

### 1. Clustered Index

* Physically sorts table data
* Only **one per table**

### Syntax

```sql
CREATE CLUSTERED INDEX idx_emp_eid
ON tbl_emp(eid);  -- Table data will be ordered by eid
```

---

### 2. Non-Clustered Index

* Separate structure
* Multiple allowed

### Syntax

```sql
CREATE NONCLUSTERED INDEX idx_emp_name
ON tbl_emp(name);  -- Speeds up search by name
```

---

### 3. Composite Index (Multiple columns)

```sql
CREATE NONCLUSTERED INDEX idx_emp_dept_salary
ON tbl_emp(dept_id, salary);  
-- Useful when query filters both columns
```

---

## How Index Improves Performance

Query:

```sql
SELECT *
FROM tbl_emp
WHERE dept_id = 2;
```

If index exists on `dept_id`:

* SQL uses **Index Seek**
* Very fast

Without index:

* SQL does **Table Scan**
* Slow for large tables

---

## When NOT to use Index

* Small tables
* Columns frequently updated
* Columns with very few unique values (like Gender)

Because:

* Index slows down INSERT/UPDATE/DELETE

---

## Drop Index

```sql
DROP INDEX idx_emp_name ON tbl_emp;
```

---


| View                          | Index                        |
| ----------------------------- | ---------------------------- |
| Virtual table                 | Performance structure        |
| Stores query                  | Stores sorted data reference |
| Used for readability/security | Used for speed               |

---

# Real-world Usage

Views:

* Reporting layer
* Power BI datasets
* Application queries

Indexes:

* Large tables
* High-performance systems
* Production databases

---

# One-line Memory

View simplifies data access; Index improves data retrieval speed.

---

# Trigger

## What is a Trigger?

A **Trigger** is something that runs **automatically** when data changes.

Think like this:

> When something happens → Trigger runs automatically

Example:

* When a new employee is added → Save log
* When salary is updated → Track change
* When someone deletes data → Stop it

You **do not run a trigger manually**.

---

# Real-Life Example

### Situation

You want to know:

> Who inserted data into employee table and when?

So whenever someone inserts a row, a log should be created automatically.

---

# Step 1: Create Employee Table

```sql
CREATE TABLE tbl_emp
(
    eid INT,
    name VARCHAR(50),
    salary INT
);
```

---

# Step 2: Create Audit Table (Log Table)

```sql
CREATE TABLE Emp_Audit
(
    eid INT,
    action_type VARCHAR(10),
    action_time DATETIME
);
```

This table will store logs.

---

# Step 3: Create Trigger

```sql
CREATE TRIGGER trg_InsertLog
ON tbl_emp
AFTER INSERT
AS
BEGIN
    INSERT INTO Emp_Audit(eid, action_type, action_time)
    SELECT 
        eid,              -- employee id inserted
        'INSERT',         -- operation type
        GETDATE()         -- current date and time
    FROM inserted;        -- inserted = new rows
END;
```

---

# Step 4: Test It

Insert data:

```sql
INSERT INTO tbl_emp VALUES (1, 'Ravi', 30000);
```

Now check audit table:

```sql
SELECT * FROM Emp_Audit;
```

You will see:

```
eid | action_type | action_time
1   | INSERT      | current time
```

You did **not run the trigger** — it ran automatically.

---

# Key Concept (Very Important)

Inside trigger:

| Table    | Meaning  |
| -------- | -------- |
| inserted | new rows |
| deleted  | old rows |

---

# Types of Triggers (Simple)

### 1. AFTER Trigger

Runs after:

* INSERT
* UPDATE
* DELETE

---

### 2. INSTEAD OF Trigger

Runs **instead of** operation.

Example: Prevent delete

```sql
CREATE TRIGGER trg_NoDelete
ON tbl_emp
INSTEAD OF DELETE
AS
BEGIN
    PRINT 'Delete not allowed';
END;
```

Now:

```sql
DELETE FROM tbl_emp WHERE eid = 1;
```

It will not delete.

---

# One-Line Understanding

Trigger = Automatic action when table data changes.

---

# When Triggers are Used in Real Projects

* Audit logs
* Track salary changes
* Prevent deletion
* Maintain history

# Trigger Examples (Simple & Practical)

We will use this table:

```sql
CREATE TABLE tbl_emp
(
    eid INT,
    name VARCHAR(50),
    salary INT
);
```

---

# Example 1: Log UPDATE (Track Salary Changes)

## Step 1: Create Audit Table

```sql
CREATE TABLE Salary_Audit
(
    eid INT,
    old_salary INT,
    new_salary INT,
    updated_time DATETIME
);
```

---

## Step 2: Create Trigger

```sql
CREATE TRIGGER trg_SalaryUpdate
ON tbl_emp
AFTER UPDATE
AS
BEGIN
    INSERT INTO Salary_Audit(eid, old_salary, new_salary, updated_time)
    SELECT 
        d.eid,          -- old data
        d.salary,       -- old salary
        i.salary,       -- new salary
        GETDATE()
    FROM inserted i
    JOIN deleted d
        ON i.eid = d.eid;
END;
```

### Concept

* `deleted` = old values
* `inserted` = new values
* Used to track changes

---

# Example 2: Prevent Low Salary

Business Rule: Salary should not be less than 10,000

```sql
CREATE TRIGGER trg_CheckSalary
ON tbl_emp
AFTER INSERT, UPDATE
AS
BEGIN
    IF EXISTS (
        SELECT * 
        FROM inserted
        WHERE salary < 10000
    )
    BEGIN
        PRINT 'Salary must be at least 10000';
        ROLLBACK;
    END
END;
```

### What happens?

If someone tries:

```sql
INSERT INTO tbl_emp VALUES (2, 'Ram', 5000);
```

The insert will fail.

---

# Example 3: Prevent Delete (INSTEAD OF)

```sql
CREATE TRIGGER trg_PreventDelete
ON tbl_emp
INSTEAD OF DELETE
AS
BEGIN
    PRINT 'Delete operation is not allowed';
END;
```

Now:

```sql
DELETE FROM tbl_emp WHERE eid = 1;
```

Row will not be deleted.

---

# Example 4: Count Total Employees Automatically

## Step 1: Summary Table

```sql
CREATE TABLE Emp_Count
(
    total_emp INT
);

INSERT INTO Emp_Count VALUES (0);
```

---

## Step 2: Trigger

```sql
CREATE TRIGGER trg_UpdateCount
ON tbl_emp
AFTER INSERT
AS
BEGIN
    UPDATE Emp_Count
    SET total_emp = total_emp + (SELECT COUNT(*) FROM inserted);
END;
```

Whenever new employees are inserted, count updates automatically.

---

# Example 5: Insert Default Salary if NULL

```sql
CREATE TRIGGER trg_DefaultSalary
ON tbl_emp
AFTER INSERT
AS
BEGIN
    UPDATE tbl_emp
    SET salary = 20000
    WHERE salary IS NULL;
END;
```

---

# Example 6: Log Deleted Records

```sql
CREATE TABLE Deleted_Emp_Log
(
    eid INT,
    name VARCHAR(50),
    deleted_time DATETIME
);
```

Trigger:

```sql
CREATE TRIGGER trg_LogDelete
ON tbl_emp
AFTER DELETE
AS
BEGIN
    INSERT INTO Deleted_Emp_Log(eid, name, deleted_time)
    SELECT 
        eid,
        name,
        GETDATE()
    FROM deleted;
END;
```

---

# Most Important Trigger Concepts

| Virtual Table | Meaning  |
| ------------- | -------- |
| inserted      | New rows |
| deleted       | Old rows |

---

# Real-Time Uses

* Audit logs
* Track salary changes
* Prevent invalid data
* Maintain counts/history
* Security control

---

# Simple Memory

Trigger = Automatic rule when INSERT, UPDATE, or DELETE happens.

